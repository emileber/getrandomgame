#summary Stuff To Do and how it works
#labels Phase-Requirements,Phase-Implementation,Featured

= Getting Started =
<g:plusone/>

Table Of Content:
<wiki:toc max_depth="2" />
----
= IMPORTANT =
<font color="red">if you don't have your development environment ready, [Setup see this].</font>

----
= OMG there's a lot of files =

Ne vous perdez pas, je suis la!

Donc, jusqu'à maintenant, le projet est divisé en 2 parties distinctes, soit le Tile Engine et le Jeu (notre but).

Le jeu utilise le Tile Engine qui lui est générique et ne devrait pas contenir de code spécifique au jeu évidement.

En gros, le Tile Engine comprend la base dans le Dossier TileEngine et le Jeu contient ses fichiers, qui héritent du Tile Engine, dans le dossier GetRandomGame. Chaque classe de l'Engine est dans le namespace TileEngine.

Voici une ébauche rapide de ce qu'il contiennent présentement en date de la r75:
  * ====GetRandomGame (namespace) ====
    * GetRandomGame (Sous-classe Environement, big mama du jeu)
    * GRGInputHandler
    * Launcher
  * ==== TileEngine (namespace) ====
    * ==== Graphic ====
      * Font : Ressource (Font est déclaré dedans)  - pas encore implémenté
      * Texture : Ressource (Texture est déclaré dedans)
      * (1)Camera (the view point)
      * (1)Graphic (Interface Singleton
      * Animation : Ressource (Animation déclaré dedans) - pas encore implémenté
      * GraphicType (défini les structures du type rect et section et point)
    * Global (constante et include)
    * Environment (Environment générique, redéfini par GetRandomGame)
    * InputHandler (générique, contient pratiquement rien)
    * (1)SDLInterface (Encapsulation de fonction relié à SDL)
    * (1)Engine (la boucle de jeu)
    * Timer (donne du temps en milisec avec le tick SDL)
    * World (monde de jeu générique, presque vide aussi, c'est a redéfinir dans le jeu)
  * ==== Util ====
    * Singleton (Template pour créer des singleton sans avoir a implémenter le code dans chaque classe)
    * (1)Manager (Template class, sert de genre de Factory)
    * Ressource (Classe Abstraite Pure pour les ressources du manager)

(1) = Singleton, class Specific : class Parent

== Global.h WTF? ==

Je vais faire référence souvent à ce fichier, c'est le fichier de constante de jeu et des Enumerations (comme les Layer présentement). Il est peut-être mauvais de passer les constantes comme ça, ça reste à revérifier et c'est pas définitif.

----
= Le Tile Engine =

Petite explication rapide de l’engin. Prendre note que la classe Engine est Singleton.

== Pour le starter ==

{{{
// voir le Launcher dans le dir GetRandomGame pour le code exact

Engine::getInstance()->init(SCREEN_WIDTH, SCREEN_HEIGHT, "window caption", 
                   "font.ttf", Environment, InputHandler);

Engine::getInstance()->start();
}}}

Il est important de faire Init en premier, mais ça on s'en fou, je l'ai fait, on risque de plus y toucher.

== Création ==

À sa création, l'Engine initialise l'interface Graphic ainsi que l'environment.

NOTE: Graphic est singleton aussi ainsi que tous les Manager graphique.

Ensuite, il appelle run() qui start le gameLoop.

== Le Game Loop ==

{{{
         /**
         *  GAME LOOP
         */
        while (!_quit) {
                /**
                 * each iteration, do this:
                 */

                _frameTimer.start(); //Calcul le temps d'execution de l'iteration

                // Collect and handle inputs informations (return false on exit)
                _quit = _inputHandler->handleInput(_environment);

                _environment->update(); // UPDATE the environment

                if (DEBUG) {
                        fpsRegulator(); // show FPS information
                }


                _graphic->clearScreen(); // (OpenGL)clear the screen

                // all the draw OPs
                _environment->draw(); // call le draw de toute

                _graphic->flipBuffers(); // (OpenGL)flip the screen

                // wait the time left after the last loop (timeLeft = timeEachLoop - timeTakenThisLoop)
                while (_frameTimer.get_ticks() < 1000 / FRAMES_PER_SECOND)
                        ;
                frameCount++; // test frame count
        } // End of the GAME LOOP

}}}

== Regulation des Frame par seconde ==

On voit dans la ligne:
{{{
while (_frameTimer.get_ticks() < 1000 / FRAMES_PER_SECOND)
			;
}}}
que la boucle est géré par FPS. Elle attend seulement le temps restant pour garder sont taux de FPS. (Par contre, présentement le cap est a 200 je crois, c'est a confirmer dans le fichier Global.h mais évidement, elle attend pas vraiment)

Le cap de FPS présentement tourne autour de 60 fps.

== La classe Environment ==

Celle du namespace TileEngine est vraiment générique et ne contient que des fonctions à redéfinir ou presque. Voir GetRandomGame qui est la sous-classe Environment de notre jeu.

L’environnement crée un monde et s'occupe d'updater les objets actifs dont notre personnage Héro évidement et ensuite de l'afficher (Draw) en succession. C'est-à-dire, L'Engine appel le Draw d'environment qui appel le Draw du World, lui qui appel le Draw de chaque partie (Area, tuiles, etc.) et ensuite l'environment appel le Draw des éléments actifs, soit les personnages et monstres.

----
= L'interface graphique avec SDL (un démon) et OpenGL (le diable en personne) =

Bon alors j'ai encapsulé le boute chiant donc vous n'aurai pas a jouer avec des trucs d'affichage.

Lorsque terminé, l'interface permettra les choses suivantes:
  * afficher des images (même en dehors de l'écran, ça fais pas d'erreur c'est correct et normal de le faire, bien que l'on ne le voit pas)
  * afficher du texte
  * Sur x Layer différentes (et c'est ajustable à volonter)
  * transparence
  * Rotation
  * Resize
  * Teinte (couleur ajusté, comme les biomes dans Minecraft, les textures seront en grayscale)
  * Éventuellement, un éclairage dynamique.

== Son contenu ==

Ce qui est interessant:
{{{
 // Les fonctions de dessins: 
Graphic::getInstance()->drawRectangle(GLfloat x, GLfloat y, GLfloat width, GLfloat height, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
 // drawFilledRectangle(GLfloat x, GLfloat y, GLfloat width, GLfloat height, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
 // drawLine(GLfloat x, GLfloat y, GLfloat x2, GLfloat y2, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)

}}}
La plupart des fonctions sont auto-explicatives.

== Comment afficher une image? ==

  # Crée une Texture ou une Animation
  # À chaque iteration, appeler la fonction "draw" de cet objet. (soit dans le draw de l'environnement ou de la classe parente)


{{{
// Load une texture
Texture * textureTest = Manager<Texture>::getInstance()->loadRessource(filename);

// dessine une texture
textureTest->draw(GLfloat x, GLfloat y, GLfloat scale = 1, GLfloat rotation = 0, GLfloat red = 1, GLfloat green = 1, GLfloat blue = 1, GLfloat alpha = 1);

// aussi, il y a drawSection qui est importante
}}}

----
= Util =

Dans notre projet, il y a un dossier nommé Util. Il contient des classes et des templates génériques qui ne font pas parti du namespace TileEngine. Ils sont par contre essentiels.

== Singleton ==

Le [http://en.wikipedia.org/wiki/Singleton_pattern concept du singleton] est de limiter la création d'une classe à une instance unique et de la rendre en même temps globale. Pour y arriver, nous laissons le soin à la classe elle-même de gérer sa création par le biais du Design Pattern nommé Singleton.

J'ai donc inclue un Template du Singleton qui nous permet de facilement créer une classe singleton. Comment y arriver?
  # Crée une nouvelle classe et fais la hériter de Singleton`<taClasse>`
  # Ensuite, question de respecter le principe du Singleton, ajoute la classe singleton comme étant un FRIEND comme ceci "friend class Singleton`<taClasse>`;"
  # Place les constructeur/destructeur dans la partie privé de la classe
  # accède de n'importe où à l'instance unique de ta classe avec: "taClasse::getInstance();"

=== Exemple de Singleton ===
{{{
class TaClasse: public Singleton<TaClasse> {
	friend class Singleton<TaClasse> ;
public:

	// fonctions public
private:
	TaClasse() {
	}
	virtual ~TaClasse() {
	}

	// membres privés
};
}}}

== Manager et Ressource ==

De façon à limiter l'ouverture d'un fichier et de son chargement à une unique fois, il nous faut une classe qui gère cela et nous l'appelons ici le Manager. De façon à avoir accès à un Manager unique et ce partout, chaque Manager doit être Singleton et c'est pourquoi la classe créé gère cela elle-même.

Le Manager est une classe Template, donc elle s'ajuste au contenu qu'elle gère mais pour s'assurer du bon fonctionnement de la classe et de l'implémentation des bonnes fonctions, chaque classe que le manager devra géré DOIT IMPÉRATIVEMENT hériter de la classe abstraite Ressource.

Son utilisation:
  # `Manager<TaClasse_a_Manager>::getInstance()`;
  # Ensuite, utiliser la fonction loadRessource(string filename)
  # Retourne à tous coup une instance de TaClasse_a_Manager et automatiquement l'ajoute aux ressources chargées
    * Si la ressource est déjà chargé, il retourne l'instance déjà chargé.

*IMPORTANT* Le Manager se sert du nom de fichier (string filename) pour classer et donc savoir ce qui est déjà chargé.

=== la classe Manager ===
{{{
template<typename T>
class Manager: public Singleton<Manager<T> > {
	friend class Singleton<Manager<T> > ;
public:
	T * loadRessource(std::string filename) {
		if (!isLoaded(filename)) {
			T * newRessource = new T();
			newRessource->load(filename);
			registerRessource(newRessource);
			return newRessource;
		}
		return _ressourceMap[filename];
	}

	void deleteAllRessource(); // pas encore implémenté
	void reloadAllRessource() {} // pas encore implémenté

	bool isLoaded(std::string filename) {
		if (_ressourceMap.find(filename) != _ressourceMap.end()) {
			return true;
		}
		return false;
	}
        /// Add a ressource to manage
	void registerRessource(T * ressource) {
		if (!isLoaded(ressource->getFilename())) {
			_ressourceMap[ressource->getFilename()] = ressource;
		}
	}
	/// Removes a Ressource from management
	void unRegisterRessource(T * ressource) {
		if (isLoaded(ressource->getFilename())) {
			_ressourceMap.erase(ressource->getFilename());
		}
	}
private:
        // Constructor et destructor PRIVATE parce que Singleton
	Manager() {}
	virtual ~Manager() {}
	std::map<std::string, T *> _ressourceMap; // Map qui gere les ressources
};
}}}

=== Ressource ===
La classe abstraite pure Ressource sert uniquement à être hérité par une sous-classe qui sera géré par le Manager de la classe en question.

Son utilisation (Exemple avec Texture):
  # Texture hérite de Ressource
  # Texture redéfini la fonction load(string filename) et c'est OBLIGATOIRE
  # ensuite il est possible facilement de faire `Manager<Texture>::getInstance()` pour obtenir un gestionnaire de Ressource

{{{
class Ressource {
public:
	Ressource() {
		_filename = "";
		_isLoaded = false;
	}
	virtual ~Ressource() {}

	/**
	 * Pure virtual function
	 * MUST be implement
	 */
	virtual void load(std::string filename) = 0;

	std::string getFilename() const {
		return _filename;
	}
	bool isLoaded() const {
		return _isLoaded;
	}
protected:
	std::string _filename;
	bool _isLoaded;
};
}}}

----
= Les modules à développer =

== <font color="red">IMPORTANT avant de commencer</font> ==
  # Consultez les membres de l'équipe
  # Consultez la documentation sur le wiki et dans le dossier docs du projet
  # Regardez et comprenez le [http://code.google.com/p/getrandomgame/source/browse/trunk/GetRandomGame/docs/getArandomGame.uml Diagramme de Classe] (nécessite [http://staruml.sourceforge.net/en/download.php StarUML])
  # Vous ne trouvez pas de page dans le wiki sur le module que vous désirez? créez-la et expliquez votre module.
  # puis inscrivez votre nom devant l'élément de la liste que vous allez travailler. 

Donc maintenant que tout est diponible pour starter, il ne vous reste plus qu'à prendre le module suivant qui vous intéresse:
  * <font size="3" color="green">Paufiner le Tile Engine (Emile)</font>
    * Ajout d'openGL (voir aussi pour dynamic lighting) EN COURS
    * Gestion de l'affichage
    * Gestion des contrôles
    * Peut-être ajouter un aspect réseau
  * <font size="3" color="green">Créer le Monde [World (voir la page)] (Alexandre DT est pas mal la dessus)</font>
    * une fois une tile map affichée, il faut le coté RANDOM de la map
  * Les menu/interface (inventaire, stats, hotbar, healt/xp/mana bar, etc)
    * ça implique faire des classes générique genre Button et Labels et Menu, voir Class Diagram et Maquette
  * Les Tokens
    * Ainsi que des états comme (en feu, gelé, électrifiant, etc, voir [Features features])
  * Le système de génération d'item
    * Donc faire les classes Item et Inventaire
    * puis importer le système de génération aléatoire avec préfixe et suffixe
    * Le système de crafting
  * <font size="3" color="green">Les Characters (FreD)</font>
    * Player (FreD)
    * NPC
    * Monsters
  * <font size="3" color="green">Le système d'interaction (bebleu)</font>
    * Mouvement dans les tuiles
    * interaction de combat autant qu'avec des objets (classe générique Interaction)

    * Les interactions Magiques (spells)
    * Interactions sociales
  * Le pathfinding
    * Pour notre personnage lors de mouvement avec clique
    * Pour les NPC (A`*` probablement)
  * L’intelligence Artificiel
    * Passive/agressive directe ou indirect etc
  * Game State
    * Menu principal
    * Login au serveur et loading screen (si réseau)

Finalement
  * Définir les règles de jeu précises
  * Un éditeur pour ajouter du contenu facilement
  * des animations
  * autre contenu

Merci et bon développement!

Voilà, s'il manque quelque chose, n'hésitez pas à modifier les pages.