#summary Stuff To Do and how it works
#labels Phase-Requirements,Phase-Implementation,Featured

= Getting Started =
<g:plusone/>

Table Of Content:
<wiki:toc max_depth="2" />
----
= IMPORTANT =
if you don't have your development environment ready, [Setup see this].

----
= OMG there's a lot of files =

Ne vous perdez pas, je suis la!

Donc, jusqu'à maintenant, le projet est divisé en 2 parties distinctes, soit le Tile Engine et le Jeu (notre but).

Le jeu utilise le Tile Engine qui lui est générique et ne devrait pas contenir de code spécifique au jeu évidement.

En gros, le Tile Engine comprend la base dans le Dossier TileEngine et le Jeu contient ses fichiers, qui héritent du Tile Engine, dans le dossier GetRandomGame. Chaque classe de l'Engine est dans le namespace TileEngine.

Voici une ébauche rapide de ce qu'il contiennent présentement en date de la r75:
  * ====GetRandomGame (namespace) ====
    * GetRandomGame (Sous-classe Environement, big mama du jeu)
    * GRGInputHandler
    * Launcher
  * ==== TileEngine (namespace) ====
    * ==== Graphic ====
      * Font : Ressource (Font est déclaré dedans)  - pas encore implémenté
      * Texture : Ressource (Texture est déclaré dedans)
      * (1)Camera (the view point)
      * (1)Graphic (Interface Singleton
      * Animation : Ressource (Animation déclaré dedans) - pas encore implémenté
      * GraphicType (défini les structures du type rect et section et point)

    * Global (constante et include)
    * Environment (Environment générique, redéfini par GetRandomGame)
    * InputHandler (générique, contient pratiquement rien)
    * (1)SDLInterface (Encapsulation de fonction relié à SDL)
    * (1)Engine (la boucle de jeu)
    * Timer (donne du temps en milisec avec le tick SDL)
    * World (monde de jeu générique, presque vide aussi, c'est a redéfinir dans le jeu)
  * ==== Util ====
    * Singleton (Template pour créer des singleton sans avoir a implémenter le code dans chaque classe)
    * (1)Manager (Template class, sert de genre de Factory)
    * Ressource (Classe Abstraite Pure pour les ressources du manager)

(1) = Singleton, class Specific : class Parent

== Global.h WTF? ==

Je vais faire référence souvent à ce fichier, c'est le fichier de constante de jeu et des Enumerations (comme les Layer présentement). Il est peut-être mauvais de passer les constantes comme ça, ça reste à revérifier et c'est pas définitif.

----
= Le Tile Engine =

Petite explication rapide de l’engin. Prendre note que la classe Engine est Singleton.

== Pour le starter ==

{{{
// voir le Launcher dans le dir GetRandomGame pour le code exact

Engine::getInstance()->init(SCREEN_WIDTH, SCREEN_HEIGHT, "window caption", 
                   "font.ttf", Environment, InputHandler);

Engine::getInstance()->start();
}}}

Il est important de faire Init en premier, mais ça on s'en fou, je l'ai fait, on risque de plus y toucher.

== Création ==

À sa création, l'Engine initialise l'interface Graphic ainsi que l'environment.

NOTE: Graphic est singleton aussi ainsi que tous les Manager graphique.

Ensuite, il appelle run() qui start le gameLoop.

== Le Game Loop ==

{{{
         /**
         *  GAME LOOP
         */
        while (!_quit) {
                /**
                 * each iteration, do this:
                 */

                _frameTimer.start(); //Calcul le temps d'execution de l'iteration

                // Collect and handle inputs informations (return false on exit)
                _quit = _inputHandler->handleInput(_environment);

                _environment->update(); // UPDATE the environment

                if (DEBUG) {
                        fpsRegulator(); // show FPS information
                }


                _graphic->clearScreen(); // (OpenGL)clear the screen

                // all the draw OPs
                _environment->draw(); // call le draw de toute

                _graphic->flipBuffers(); // (OpenGL)flip the screen

                // wait the time left after the last loop (timeLeft = timeEachLoop - timeTakenThisLoop)
                while (_frameTimer.get_ticks() < 1000 / FRAMES_PER_SECOND)
                        ;
                frameCount++; // test frame count
        } // End of the GAME LOOP

}}}

== Regulation des Frame par seconde ==

On voit dans la ligne:
{{{
while (_frameTimer.get_ticks() < 1000 / FRAMES_PER_SECOND)
			;
}}}
que la boucle est géré par FPS. Elle attend seulement le temps restant pour garder sont taux de FPS. (Par contre, présentement le cap est a 200 je crois, c'est a confirmer dans le fichier Global.h mais évidement, elle attend pas vraiment)

Le cap de FPS présentement tourne autour de 60 fps.

== La classe Environment ==

Celle du namespace TileEngine est vraiment générique et ne contient que des fonctions à redéfinir ou presque. Voir GetRandomGame qui est la sous-classe Environment de notre jeu.

L’environnement crée un monde et s'occupe d'updater les objets actifs dont notre personnage Héro évidement et ensuite de l'afficher (Draw) en succession. C'est-à-dire, L'Engine appel le Draw d'environment qui appel le Draw du World, lui qui appel le Draw de chaque partie (Area, tuiles, etc.) et ensuite l'environment appel le Draw des éléments actifs, soit les personnages et monstres.

----
= L'interface graphique avec SDL (un démon) et OpenGL (le diable en personne) =

Bon alors j'ai encapsulé le boute chiant donc vous n'aurai pas a jouer avec des trucs d'affichage.

Lorsque terminé, l'interface permettra les choses suivantes:
  * afficher des images (même en dehors de l'écran, ça fais pas d'erreur c'est correct et normal de le faire, bien que l'on ne le voit pas)
  * afficher du texte
  * Sur x Layer différentes (et c'est ajustable à volonter)
  * transparence
  * Rotation
  * Resize
  * Teinte (couleur ajusté, comme les biomes dans Minecraft, les textures seront en grayscale)
  * Éventuellement, un éclairage dynamique.

== Son contenu ==

Ce qui est interessant:
{{{
 // Les fonctions de dessins: 
Graphic::getInstance()->drawRectangle(GLfloat x, GLfloat y, GLfloat width, GLfloat height, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
 // drawFilledRectangle(GLfloat x, GLfloat y, GLfloat width, GLfloat height, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
 // drawLine(GLfloat x, GLfloat y, GLfloat x2, GLfloat y2, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)

}}}
La plupart des fonctions sont auto-explicatives.

== Comment afficher une image? ==

  # Crée une Texture ou une Animation
  # À chaque iteration, appeler la fonction "draw" de cet objet. (soit dans le draw de l'environnement ou de la classe parente)


{{{
// Load une texture
Texture * textureTest = Manager<Texture>::getInstance()->loadRessource(filename);

// dessine une texture
textureTest->draw(GLfloat x, GLfloat y, GLfloat scale = 1, GLfloat rotation = 0, GLfloat red = 1, GLfloat green = 1, GLfloat blue = 1, GLfloat alpha = 1);

// aussi, il y a drawSection qui est importante
}}}

----
= Util =

Dans notre projet, il y a un dossier nommé Util. Il contient des classes et des templates génériques qui ne font pas parti du namespace TileEngine. Ils sont par contre essentiels.

== Singleton ==

Le [http://en.wikipedia.org/wiki/Singleton_pattern concept du singleton] est de limiter la création d'une classe à une instance unique et de la rendre en même temps globale. Pour y arriver, nous laissons le soin à la classe elle-même de gérer sa création par le biais du Design Pattern nommé Singleton.

J'ai donc inclue un Template du Singleton qui nous permet de facilement créer une classe singleton. Comment y arriver?
  # Crée une nouvelle classe et fais la hériter de Singleton`<taClasse>`
  # Ensuite, question de respecter le principe du Singleton, ajoute la classe singleton comme étant un FRIEND comme ceci "friend class Singleton`<taClasse>`;"
  # Place les constructeur/destructeur dans la partie privé de la classe
  # accède de n'importe où à l'instance unique de ta classe avec: "taClasse::getInstance();"

=== Exemple de Singleton ===
{{{
class TaClasse: public Singleton<TaClasse> {
	friend class Singleton<TaClasse> ;
public:

	// fonctions public
private:
	TaClasse() {
	}
	virtual ~TaClasse() {
	}

	// membres privés
};
}}}

----
= Les modules à développer =

Donc maintenant que tout est diponible pour starter, il ne vous reste plus qu'à prendre le module suivant qui vous intéresse:
  * Paufiner le Tile Engine (je risque de faire ça)
    * Ajout d'openGL (voir aussi pour dynamic lighting) EN COURS
    * Gestion de l'affichage
    * Gestion des contrôles
    * Peut-être ajouter un aspect réseau
  * Créer le Monde [World (voir la page)]
    * une fois une tile map affichée, il faut le coté RANDOM de la map
  * Les menu/interface (inventaire, stats, hotbar, healt/xp/mana bar, etc)... je sais, c'est pas le plus le fun
    * ça implique faire des classes générique genre Button et Labels et Menu, voir Class Diagram et Maquette
  * Les Tokens
    * Ainsi que des états comme (en feu, gelé, électrifiant, etc, voir [Features features])
  * Le système de génération d'item
    * Donc faire les classes Item et Inventaire
    * puis importer le système de génération aléatoire avec préfixe et suffixe
    * Le système de crafting
  * Les Characters
    * Player
    * NPC
    * Monsters
  * Le système d'interaction
    * Mouvement dans les tuiles
    * interaction de combat autant qu'avec des objets (classe générique Interaction)
    * Les interactions Magiques (spells)
    * Interactions sociales
  * Le pathfinding
    * Pour notre personnage lors de mouvement avec clique
    * Pour les NPC (A`*` probablement)
  * L’intelligence Artificiel
    * Passive/agressive directe ou indirect etc
  * Game State
    * Menu principal
    * Login au serveur et loading screen (si réseau)

Finalement
  * Définir les règles de jeu précises
  * Un éditeur pour ajouter du contenu facilement
  * des animations
  * autre contenu

== IMPORTANT ==
Consulter les membres de l'équipe et surtout la documentation sur le wiki et dans le dossier docs du projet AVANT de commencer à travailler, puis inscrivez votre nom devant l'élément de la liste que vous allez travailler. Merci!

Voilà, s'il manque quelque chose, n'hésitez pas à modifier les pages.